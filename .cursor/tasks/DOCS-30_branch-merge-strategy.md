# ブランチ（イシュー）のマージ戦略をまとめる

親子イシュー開発時のブランチマージ戦略をドキュメント化し、コミット履歴を綺麗に保つためのワークフローを確立する。

## 背景

### 問題

親子イシュー構造で開発する際、以下のような問題が発生していた：

1. **子ブランチを親ブランチにマージ後、同じ子ブランチで作業を続けると履歴が汚くなる**
   - 子ブランチ → 親ブランチへマージ（1回目）
   - 子ブランチで追加作業
   - 子ブランチ → 親ブランチへ再マージ（2回目）
   - **結果**: コミットの重複、複雑なマージグラフ、履歴が追いにくい

2. **原因**
   - 親ブランチ側: マージコミット or squash で履歴が変わる
   - 子ブランチ側: 元の履歴を保持している
   - 同じ変更が異なるコミットハッシュで存在 → rebase しても重複が発生

3. **従来の対応**
   - なんとなく rebase を繰り返す → 解決しない
   - 履歴が汚いまま放置
   - コードレビューが困難

### 目標

- 親子イシュー開発時のマージ戦略を明確化
- ケースバイケースで使い分けられる複数の選択肢を用意
- 履歴を綺麗に保つためのワークフローを確立
- `.cursor/rules/git/` にドキュメントとして追加

## Completed Tasks

- [x] worktree を作成（`~/MyDev/cursor/worktrees/docs-30-branch-merge-strategy`）
- [x] タスクファイルを作成（`.cursor/tasks/DOCS-30_branch-merge-strategy.md`）
- [x] イシュー description を作成（`.cursor/tasks/ref/ref-DOCS-30_issue-description.md`）
- [x] マージ戦略ドキュメントを作成（`.cursor/rules/git/merge-strategy.mdc`）
- [x] オプション1（新しいブランチ）の詳細を記載
- [x] オプション2（リセットして同期）の詳細を記載
- [x] 判断基準の表を作成
- [x] 実践的なルール（鉄則1〜3）を追加
- [x] よくある失敗パターンと対処法を記載
- [x] トラブルシューティング（Q&A）を追加
- [x] worktree環境での実践例を3ケース追加
- [x] ドキュメントを大幅簡素化（438行→124行）
- [x] 推奨方法をオプション2（子ブランチ同期）に変更
- [x] タスクファイルの背景知識蓄積を理由として明記
- [x] 懸念点（何度もPRを出す場合）を記載

## In Progress Tasks

## Future Tasks

- [x] 既存の worktree.mdc、commit.mdc との連携を確認（関連ドキュメントセクションで明記）
- [ ] 実際に運用してフィードバック収集（運用後の課題）
- [ ] 必要に応じてドキュメントを改善（運用後の課題）

## Implementation Plan

### 目標

1. **マージ戦略の明確化**
   - オプション1: 子ブランチを終了して新しいブランチを作る（推奨）
   - オプション2: 子ブランチを親に同期させる
   - どちらを使うべきかの判断基準

2. **実践的なコマンド例**
   - 各オプションの具体的な手順
   - トラブルシューティング
   - よくある失敗パターン

3. **既存ルールとの統合**
   - `@git/worktree.mdc` との連携
   - `@git/commit.mdc` との整合性
   - `@cursor-tasks.mdc` のタスク管理との関係

### マージ戦略の詳細

#### オプション1: 子ブランチを終了して新しいブランチを作る（推奨）

**使うべきケース**:
- 機能が明確に分離できる場合
- フェーズごとに PR を分けたい場合
- レビューを段階的に受けたい場合

**手順**:
```bash
# 子ブランチを親にマージした後

# 1. 親ブランチを最新化
cd /path/to/worktree/親ブランチ
git pull origin 親ブランチ

# 2. 新しい子ブランチを作成
git worktree add ../子ブランチ-phase2 -b 子ブランチ-phase2
cd ../子ブランチ-phase2

# 3. 続きの作業をここで実施
```

**メリット**:
- 履歴が綺麗（各 PR が独立）
- 問題が起きない（履歴の競合なし）
- レビューがしやすい（変更が明確）

**デメリット**:
- ブランチが増える
- worktree が増える
- ブランチ名を考える必要がある

#### オプション2: 子ブランチを親に同期させる

**使うべきケース**:
- 同じ子ブランチで作業を続けたい場合
- ブランチ名を変えたくない場合
- 小さな追加修正が必要な場合

**手順**:
```bash
# 子ブランチを親にマージした後、子ブランチで作業を続ける場合

cd /path/to/worktree/子ブランチ

# 1. 親の最新を取得
git fetch origin 親ブランチ

# 2. 子ブランチを親の最新にリセット（強制的に同期）
git reset --hard origin/親ブランチ

# 3. これで子ブランチ = 親ブランチになる
# 4. ここから新しい作業を開始
git add .
git commit -m "追加の変更"

# 5. プッシュ（force push が必要）
git push origin 子ブランチ --force-with-lease
```

**メリット**:
- 同じブランチで作業を続けられる
- worktree を再作成しなくて良い
- シンプル（ブランチが増えない）

**デメリット**:
- 子ブランチのローカルコミット履歴が消える（既にマージ済みなので通常は問題ない）
- force push が必要
- 注意しないと作業中の変更を失う可能性

#### 判断基準

| 状況 | 推奨 | 理由 |
|------|------|------|
| 大きな機能を複数フェーズに分ける | オプション1 | 各フェーズが独立してレビューしやすい |
| マージ後に軽微な修正が必要 | オプション2 | ブランチを増やす必要がない |
| 継続的に機能を追加していく | オプション1 | 履歴が追いやすい |
| PRマージ直後の修正（typo等） | オプション2 | 手軽に対応できる |

### 実践的なルール

#### 📌 鉄則1: 子ブランチは1回のPRで終了を基本とする

```
親ブランチ
 ├─ 子ブランチA（1つの機能） → マージしたら終了
 ├─ 子ブランチB（別の機能） → マージしたら終了
 └─ 子ブランチC（さらに別の機能） → マージしたら終了
```

#### 📌 鉄則2: マージ後に続けるなら必ずリセット

```bash
# 子ブランチをマージした後
git reset --hard origin/親ブランチ
# これで子ブランチ = 親ブランチ（同期完了）
```

#### 📌 鉄則3: 大きな機能はフェーズ分け

```
親イシュー #118: プロジェクトドキュメント整備
 ├─ 子イシュー #119-phase1: 設計書の骨格
 ├─ 子イシュー #119-phase2: 詳細設計
 └─ 子イシュー #119-phase3: 図表追加
```

### よくある失敗パターンと対処法

#### 失敗1: 子ブランチをマージ後、rebase だけで対応しようとする

**問題**:
```bash
# これだけではダメ
git rebase origin/親ブランチ
# → コミットの重複、履歴が汚くなる
```

**正しい対応**:
```bash
# オプション2を使う
git reset --hard origin/親ブランチ
```

#### 失敗2: 複数の子ブランチを同時に親にマージして混乱

**問題**:
- 子ブランチA、Bを同時に親にマージ
- どの変更がどこから来たか分からない

**正しい対応**:
- 1つずつ順番にマージ
- マージ後、他の子ブランチも親の最新にリセット

#### 失敗3: force push を恐れて履歴を放置

**問題**:
- `--force-with-lease` を使わずに履歴が汚いまま

**正しい対応**:
- オプション2を使った後は必ず `--force-with-lease`
- 安全な force push

### トラブルシューティング

#### Q: リセット後に未保存の変更が消えた

**A**: リセット前に stash するか、別ブランチに退避
```bash
# リセット前
git stash
# または
git branch 退避用ブランチ

# リセット
git reset --hard origin/親ブランチ

# 変更を戻す
git stash pop
# または
git cherry-pick 退避用ブランチ
```

#### Q: どちらのオプションを使うべきか迷う

**A**: 迷ったらオプション1（新しいブランチ）を使う
- より安全
- 履歴が綺麗
- レビューしやすい

#### Q: 既に履歴が汚くなってしまった

**A**: 親ブランチの最新から作り直す
```bash
# 変更を確認
git diff origin/親ブランチ

# 変更を一時保存
git diff origin/親ブランチ > changes.patch

# リセット
git reset --hard origin/親ブランチ

# パッチを適用
git apply changes.patch
git commit -am "整理した変更"
```

### ドキュメント構成

```
.cursor/rules/git/
├── commit.mdc          # コミット時のルール
├── issue.mdc           # イシュー作成後のワークフロー
├── worktree.mdc        # worktree による並列開発
└── merge-strategy.mdc  # ← 新規作成（今回）
```

### 既存ルールとの関連

- **`@git/worktree.mdc`**: worktree の作成・管理方法
- **`@git/commit.mdc`**: コミットメッセージ、`.cursor/` の扱い
- **`@cursor-tasks.mdc`**: タスクファイルの管理
- **`@git/issue.mdc`**: イシュー駆動開発のフロー

今回の `merge-strategy.mdc` はこれらと連携して、**マージ時の具体的な手順**を提供する。

## Relevant Files

- `.cursor/rules/git/merge-strategy.mdc` - マージ戦略ドキュメント（メイン成果物）✅
- `.cursor/tasks/DOCS-30_branch-merge-strategy.md` - このタスクファイル ✅
- `.cursor/tasks/ref/ref-DOCS-30_issue-description.md` - GitHub イシュー用 description ✅
- `.cursor/rules/git/worktree.mdc` - 既存の worktree ルール（参照・連携確認）
- `.cursor/rules/git/commit.mdc` - 既存のコミットルール（参照・連携確認）
- `.cursor/rules/git/issue.mdc` - 既存のイシュールール（参照・連携確認）
- `.cursor/rules/cursor-tasks.mdc` - タスク管理ルール（参照）

