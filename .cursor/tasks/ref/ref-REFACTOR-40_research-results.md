# Production/Main ブランチ構造差異の調査結果

手段8（Production ブランチ構造変更）について、mainブランチとproductionブランチで構造が異なることが一般的なのか調査した結果。

## 調査概要

**調査日**: 2025-10-22  
**調査方法**: Web検索による事例・ベストプラクティスの調査  
**調査対象**: GitHub Pages、npm パッケージ、orphan ブランチ、配布用ブランチなど

---

## 調査結果サマリー

### 結論

**「よくあることではあるが、一般的には推奨されない」**

- ✅ **ビルド成果物や配布物を別ブランチに配置する**ケースは実際に存在する
- ⚠️ ただし、**ドキュメント化と自動化が前提**
- ❌ 手動で異なる構造を維持するのは混乱の元
- 📝 一貫性を保つことが基本的なベストプラクティス

---

## 具体的な事例

### 1. GitHub Pages (gh-pages ブランチ)

**最も一般的な「構造が異なるブランチ」の事例**

#### パターンA: main vs gh-pages

```
main ブランチ（ソースコード）:
  src/
  components/
  docs-source/
  package.json
  README.md

gh-pages ブランチ（ビルド成果物）:
  index.html
  assets/
    css/
    js/
    images/
  404.html
```

#### 特徴
- ✅ **完全に異なる構造**（ソース vs ビルド成果物）
- ✅ GitHub Actions で自動ビルド・デプロイ
- ✅ Orphan ブランチとして管理されることが多い
- ✅ ユーザーは gh-pages ブランチを直接触らない

#### 類似性
- 今回の production ブランチと似ている
- main で開発 → production で配布という構造

---

### 2. npm パッケージ（dist ブランチパターン）

**一部のnpmパッケージで採用されていたパターン（現在は非推奨）**

#### 過去のパターン

```
main ブランチ:
  src/
    index.ts
    components/
  tests/
  .gitignore
  package.json

dist ブランチ:
  index.js
  index.d.ts
  components/
    Button.js
    Button.d.ts
  package.json
```

#### 現状
- ❌ **現在はほとんど使われていない**
- ✅ 代わりに `.npmignore` や `files` フィールドで制御
- ✅ npm publish 時に `dist/` のみ公開する方式が主流

#### 理由
- メンテナンスコストが高い
- 自動化が複雑
- ブランチ間の同期がずれやすい

---

### 3. ドキュメント生成ツール（VitePress, MkDocs等）

**ドキュメントサイトでのパターン**

#### パターン

```
main ブランチ:
  docs/          # マークダウンソース
    getting-started.md
    api.md
  .vitepress/
  src/           # アプリケーションコード

gh-pages ブランチ:
  index.html     # 生成されたHTML
  assets/
  getting-started.html
  api.html
```

#### 特徴
- ✅ ソース（Markdown）と成果物（HTML）を分離
- ✅ CI/CDで自動生成・デプロイ
- ✅ 手動操作は不要

---

## 一般的なベストプラクティス

### 推奨される原則

#### 1. **一貫性の維持**
- ブランチ間でディレクトリ構造は統一すべき
- 開発者の混乱を防ぐ
- メンテナンス性を向上させる

出典：
- [株式会社スリーシェイク - ディレクトリ構成の良いプラクティス](https://sreake.com/blog/directory-structure-good-practice/)
- Spring Boot ドキュメント

#### 2. **変更容易性**
- 機能が疎結合
- 影響範囲が局所的
- 新機能追加や仕様変更に柔軟

#### 3. **ドキュメント化**
- ブランチごとの違いを明確に記述
- チーム全体で共有
- 混乱を防ぐ

#### 4. **自動化**
- ビルドプロセスで構造の違いを吸収
- 手動操作を排除
- CI/CDで一貫性を保証

---

## 構造が異なる場合の注意点

### デメリット

1. **開発者の混乱**
   - ブランチ切り替え時に戸惑う
   - 新規参加者の学習コスト増加

2. **メンテナンスの複雑化**
   - 同期が必要な場合、手間が増える
   - 自動化スクリプトの維持が必要

3. **デプロイメントプロセスの複雑化**
   - CI/CDパイプラインが複雑になる
   - エラーの原因になりやすい

### 許容されるケース

1. **ビルド成果物の配置**
   - ソースコードとビルド済みファイルは本質的に異なる
   - GitHub Pages のような明確な用途

2. **完全に分離された用途**
   - 開発者は main のみ触る
   - production は自動生成される
   - 手動での編集は想定しない

3. **明確なドキュメントと自動化**
   - 手順が明確
   - CI/CDで自動管理
   - 人的ミスが入り込まない

---

## 今回のケースへの適用

### 現在の構造

```
main ブランチ:
  .cursor/
    rules/                # ソースの配置場所
      cursor-tasks.mdc
      global.mdc
      git/
    tasks/                # タスクファイル（開発用）

production ブランチ:
  rules/                  # 配布用（.cursor/ なし）
    cursor-tasks.mdc
    global.mdc
    git/
  LICENSE
  README.md
```

### 評価

#### ✅ 許容される点
- **用途が明確**: main = 開発、production = 配布
- **完全分離**: production は自動生成（GitHub Actions）
- **ビルド成果物的**: rules/ のみを配布したい

#### ⚠️ 懸念点
- **手動での使用を想定**: ユーザーが `git clone` して手動配置
- **gh-pages ほど自明ではない**: 多くの開発者に馴染みがない
- **ドキュメント依存**: 手順を理解しないと混乱

#### ❌ 問題点（現状）
- **二重ネスト問題**: ユーザーが間違えやすい
- **不要なファイル**: LICENSE, README.md も一緒に来る
- **手順の複雑さ**: clone → mv → rm の3ステップ

---

## 代替案との比較

### オプションA: 現状維持（構造が異なる）

```
production/
  rules/          ← これを .cursor/rules として配置
    cursor-tasks.mdc
    git/
```

**評価**: ⚠️ 許容範囲だが、ユーザー体験は良くない

### オプションB: 構造を変更（手段8）

```
production/
  cursor-tasks.mdc  ← ルート直下
  global.mdc
  git/
```

**評価**: ✅ ユーザー体験が大幅に向上、構造差異は拡大

### オプションC: npm パッケージ化

```
npm install @nobunosuke/cursor-rules
# node_modules から .cursor/rules にコピー
```

**評価**: 🌟 最も標準的、バージョン管理も容易

---

## 類似プロジェクトの事例（推測）

### Cursor Rules 共有の一般的なパターン

1. **単一ファイル（.cursorrules）**
   - Gist や GitHub リポジトリで共有
   - curl でダウンロード
   - シンプルだが柔軟性に欠ける

2. **リポジトリのサブディレクトリ**
   - monorepo の一部として管理
   - git submodule で参照
   - 大規模プロジェクト向け

3. **npm パッケージ**
   - 最も標準的
   - バージョン管理が容易
   - セットアップスクリプト付属

4. **テンプレートリポジトリ**
   - GitHub Template 機能
   - 新規プロジェクト作成時にコピー
   - 個別カスタマイズ前提

---

## 結論と推奨

### 短期的解決（v1.x）

**現状維持 + ドキュメント改善**

- ✅ 実装済み（トラブルシューティング追加）
- ⚠️ 根本的な問題は残る
- 📝 明確な手順とエラー対処を提供

### 中期的解決（v2.0）

**手段8: Production ブランチ構造変更**

```bash
# ユーザー体験
git clone -b production ... .cursor/rules
rm -rf .cursor/rules/.git
```

#### 評価
- ✅ **許容される**: gh-pages パターンと類似
- ⚠️ **要ドキュメント化**: 構造の違いを明記
- ⚠️ **破壊的変更**: メジャーバージョンアップ必須

#### 実装時の注意
1. CHANGELOG で明記
2. 移行ガイド作成
3. 既存ユーザー向けアナウンス
4. v1.x のサポート期間を設定

### 長期的解決（v3.0?）

**npm パッケージ化**

```bash
npm install -D @nobunosuke/cursor-rules
npx setup-cursor-rules
```

#### メリット
- 🌟 最も標準的な配布方法
- 🌟 バージョン管理が容易
- 🌟 セットアップスクリプトで自動化
- 🌟 ユーザー体験が最高

#### デメリット
- npm アカウント・メンテナンスが必要
- セットアップスクリプトの開発コスト

---

## 最終的な判断基準

### ✅ 手段8を採用すべき場合

- ユーザーが手動セットアップを行う
- シンプルさを最優先したい
- npm エコシステムに依存したくない
- GitHub のみで完結させたい

### ❌ 手段8を避けるべき場合

- チームメンバーが混乱しやすい
- 構造の一貫性を重視する
- より標準的な方法を採用したい

### 🌟 npm パッケージ化を検討すべき場合

- 多くのユーザーに使ってもらいたい
- バージョン管理を厳密にしたい
- セットアップ体験を最高にしたい
- エコシステムに乗りたい

---

## 参考: GitHub Pages のデプロイ方法比較

GitHub は3つの方法を提供している：

1. **main ブランチの `/docs` フォルダ**
   ```
   main/
     docs/          ← ここを公開
     src/
   ```
   - 構造は同じブランチ内

2. **gh-pages ブランチのルート**
   ```
   gh-pages/        ← 完全に別構造
     index.html
   ```
   - **構造が異なる**（今回と類似）

3. **GitHub Actions でビルド**
   ```yaml
   - uses: actions/deploy-pages
   ```
   - 最も柔軟、自動化前提

GitHub 自身も「構造が異なるブランチ」を許容している。

---

## まとめ

### 質問への回答

> 手段8に関して、結構そのプロダクションとメインで構造が変わるってのはよくあることなのか？

**答え**: **「よくある」が、条件付き**

1. **✅ よくある事例**:
   - GitHub Pages (`gh-pages` ブランチ)
   - ビルド成果物の配置
   - ドキュメント生成

2. **⚠️ 条件**:
   - 自動化されている
   - 明確にドキュメント化されている
   - ユーザーが直接触らない

3. **❌ 推奨されない**:
   - 手動での構造維持
   - ドキュメント不足
   - 一貫性を欠く場合

### 今回のケースでは

**✅ 採用可能** だが、以下を条件に：
- 📝 **明確なドキュメント化** ✅（実施済み）
- 🤖 **自動化** ✅（GitHub Actions で同期）
- 🎯 **シンプルな手順** ⚠️（clone + rm）
- 🚀 **ユーザー体験** ⚠️（改善の余地あり）

### 最終推奨

1. **短期（v1.x）**: 現状維持 + トラブルシューティング ✅
2. **中期（v2.0）**: 手段8 採用（構造変更） ⭐
3. **長期（v3.0）**: npm パッケージ化を検討 🌟

手段8は「許容される範囲」であり、GitHub Pages のような先例もあるため、**メジャーバージョンアップのタイミングで採用するのは合理的**。

