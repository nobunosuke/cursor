---
description: ブランチマージ戦略
alwaysApply: false
---

# ブランチマージ戦略

## 前提

このドキュメントは **squash merge** を使う場合の戦略を説明します。

**Squash merge とは**:
- 子ブランチの複数のコミットを1つのコミットにまとめて親ブランチにマージする方法
- コミット履歴を綺麗に保てる
- 一般的には「子ブランチは使い捨て」として運用される

## 問題

子ブランチを親ブランチに squash merge した後、同じ子ブランチで作業を続けると問題が発生する。

**なぜ問題になるのか**:

```
【Squash merge前】
main:     A - B
feat/42:  A - B - C1 - C2 - C3

【Squash merge後】
main:     A - B - D (DはC1+C2+C3を1つにまとめたコミット)
feat/42:  A - B - C1 - C2 - C3 (元の履歴を保持)

【親ブランチに他の変更が入った】
main:     A - B - D - E
feat/42:  A - B - C1 - C2 - C3

【feat/42で作業を続けようとすると...】
- C1, C2, C3とDは内容が同じだが、コミットハッシュが異なる
- Gitは「異なる変更」として認識
- rebaseやmergeでコンフリクトが発生する可能性
```

## 解決策: 子ブランチを親に同期させる

### なぜこの方法を推奨するのか

`.cursor/tasks/` にイシューの背景知識・決定事項が蓄積されるため、同じブランチ（worktree）をそのまま使い続けたい。

タスクファイルは worktree に保存されているので、Git の履歴をリセットしても残る。

### 基本手順

```bash
# 【前提】子ブランチを親ブランチにsquash merge済み

# 1. 子ブランチのworktreeで作業
cd /path/to/worktree/子ブランチ

# 2. 未保存の変更がある場合は退避（なければスキップ）
git stash

# 3. 親ブランチの最新を取得
git fetch origin 親ブランチ

# 4. 子ブランチを親の最新にリセット（強制的に同期）
git reset --hard origin/親ブランチ

# 5. 退避した変更を戻す（stashした場合のみ）
git stash pop

# 6. 新しい作業を開始
# （ファイル編集...）
git add .
git commit -m "fix: 追加修正"

# 7. プッシュ（force pushが必要）
git push origin 子ブランチ --force-with-lease

# 8. 再度PR作成: 子ブランチ → 親ブランチ
```

**重要なポイント**:
- `git reset --hard` で子ブランチのGit履歴は消えるが、squash mergeで親ブランチには残っている
- タスクファイル（`.cursor/tasks/`）はworktreeに残るので、背景知識は引き継げる
- `--force-with-lease` を使うことで、リモートに他の人の変更がある場合は失敗して安全

## 注意点

### リセット前の確認事項

**未プッシュのコミットがないか確認**:
```bash
# リモートとの差分を確認
git log origin/feat/42..HEAD

# 差分がある場合はstashまたは別ブランチに退避してからリセット
```

### Force pushの安全性

**`--force-with-lease` を使う**:
- リモートに他の人の変更がある場合は失敗するので安全
- `--force` は危険なので使わない

## 関連ドキュメント

- @git/worktree.mdc - worktreeの作成・管理
- @git/commit.mdc - コミットメッセージ規約
- @git/issue.mdc - イシュー駆動開発のフロー
- @cursor-tasks.mdc - タスクファイルの管理
